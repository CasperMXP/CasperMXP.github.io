<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="java"><title>1.面试准备-Java | CHILAM</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">1.面试准备-Java</h1><a id="logo" href="/.">CHILAM</a><p class="description">Just Do IT</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">1.面试准备-Java</h1><div class="post-meta">Jun 14, 2018<span> | </span><span class="category"><a href="/categories/搬砖/">搬砖</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 11,052</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 41</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向的对象特征"><span class="toc-number">1.</span> <span class="toc-text">面向的对象特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问修饰符public-private-protected-以及不写（默认）时的区别？"><span class="toc-number">2.</span> <span class="toc-text">访问修饰符public,private,protected,以及不写（默认）时的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-是最基本的数据类型吗？"><span class="toc-number">3.</span> <span class="toc-text">String 是最基本的数据类型吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#float-f-3-4-是否正确？"><span class="toc-number">4.</span> <span class="toc-text">float f=3.4;是否正确？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><span class="toc-number">5.</span> <span class="toc-text">short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int和Integer有什么区别？"><span class="toc-number">6.</span> <span class="toc-text">int和Integer有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-和-amp-amp-的区别？"><span class="toc-number">7.</span> <span class="toc-text">&amp;和&amp;&amp;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><span class="toc-number">8.</span> <span class="toc-text">解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><span class="toc-number">9.</span> <span class="toc-text">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><span class="toc-number">10.</span> <span class="toc-text">switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用最有效率的方法计算2乘以8？"><span class="toc-number">11.</span> <span class="toc-text">用最有效率的方法计算2乘以8？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组有没有length-方法？String有没有length-方法？"><span class="toc-number">12.</span> <span class="toc-text">数组有没有length()方法？String有没有length()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="toc-number">13.</span> <span class="toc-text">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals方法介绍："><span class="toc-number">13.1.</span> <span class="toc-text">equals方法介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现高质量的equals方法的诀窍包括："><span class="toc-number">13.2.</span> <span class="toc-text">实现高质量的equals方法的诀窍包括：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><span class="toc-number">14.</span> <span class="toc-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String和StringBuilder、StringBuffer的区别？"><span class="toc-number">15.</span> <span class="toc-text">String和StringBuilder、StringBuffer的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-number">16.</span> <span class="toc-text">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#描述一下JVM加载class文件的原理机制？"><span class="toc-number">17.</span> <span class="toc-text">描述一下JVM加载class文件的原理机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类（abstract-class）和接口（interface）有什么异同？"><span class="toc-number">18.</span> <span class="toc-text">抽象类（abstract class）和接口（interface）有什么异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><span class="toc-number">19.</span> <span class="toc-text">静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-中会存在内存泄漏吗，请简单描述。"><span class="toc-number">20.</span> <span class="toc-text">Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC是什么？为什么要有GC？"><span class="toc-number">21.</span> <span class="toc-text">GC是什么？为什么要有GC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与垃圾回收相关的JVM参数："><span class="toc-number">21.1.</span> <span class="toc-text">与垃圾回收相关的JVM参数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-number">22.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error和Exception有什么区别"><span class="toc-number">23.</span> <span class="toc-text">Error和Exception有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><span class="toc-number">24.</span> <span class="toc-text">Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时异常与受检异常有何异同？"><span class="toc-number">25.</span> <span class="toc-text">运行时异常与受检异常有何异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的运行时异常"><span class="toc-number">26.</span> <span class="toc-text">常见的运行时异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类ExampleA继承Exception，类ExampleB继承ExampleA。"><span class="toc-number">27.</span> <span class="toc-text">类ExampleA继承Exception，类ExampleB继承ExampleA。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List、Set、Map是否继承自Collection接口？"><span class="toc-number">28.</span> <span class="toc-text">List、Set、Map是否继承自Collection接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。"><span class="toc-number">29.</span> <span class="toc-text">阐述ArrayList、Vector、LinkedList的存储性能和特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection和Collections的区别？"><span class="toc-number">30.</span> <span class="toc-text">Collection和Collections的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List、Map、Set三个接口存取元素时，各有什么特点？"><span class="toc-number">31.</span> <span class="toc-text">List、Map、Set三个接口存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素"><span class="toc-number">32.</span> <span class="toc-text">TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><span class="toc-number">33.</span> <span class="toc-text">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的sleep-方法和yield-方法有什么区别？"><span class="toc-number">34.</span> <span class="toc-text">线程的sleep()方法和yield()方法有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><span class="toc-number">35.</span> <span class="toc-text">当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请说出与线程同步以及线程调度相关的方法。"><span class="toc-number">36.</span> <span class="toc-text">请说出与线程同步以及线程调度相关的方法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编写多线程程序有几种实现方式？"><span class="toc-number">37.</span> <span class="toc-text">编写多线程程序有几种实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是线程池（thread-pool）"><span class="toc-number">38.</span> <span class="toc-text">什么是线程池（thread pool）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的基本状态以及状态之间的关系？"><span class="toc-number">39.</span> <span class="toc-text">线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？"><span class="toc-number">40.</span> <span class="toc-text">简述synchronized 和java.util.concurrent.locks.Lock的异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中如何实现序列化，有什么意义？"><span class="toc-number">41.</span> <span class="toc-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阐述JDBC操作数据库的步骤。"><span class="toc-number">42.</span> <span class="toc-text">阐述JDBC操作数据库的步骤。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Statement和PreparedStatement有什么区别？哪个性能更好？"><span class="toc-number">43.</span> <span class="toc-text">Statement和PreparedStatement有什么区别？哪个性能更好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><span class="toc-number">44.</span> <span class="toc-text">使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在进行数据库编程时，连接池有什么作用？"><span class="toc-number">45.</span> <span class="toc-text">在进行数据库编程时，连接池有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务的ACID是指什么？"><span class="toc-number">46.</span> <span class="toc-text">事务的ACID是指什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC中如何进行事务处理？"><span class="toc-number">47.</span> <span class="toc-text">JDBC中如何进行事务处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC能否处理Blob和Clob？"><span class="toc-number">48.</span> <span class="toc-text">JDBC能否处理Blob和Clob？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中是如何支持正则表达式操作的？"><span class="toc-number">49.</span> <span class="toc-text">Java中是如何支持正则表达式操作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简述一下面向对象的”六原则一法则”。"><span class="toc-number">50.</span> <span class="toc-text">简述一下面向对象的”六原则一法则”。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单一职责原则"><span class="toc-number">50.1.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开闭原则"><span class="toc-number">50.2.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖倒转原则"><span class="toc-number">50.3.</span> <span class="toc-text">依赖倒转原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#里氏替换原则"><span class="toc-number">50.4.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口隔离原则"><span class="toc-number">50.5.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合成聚合复用原则"><span class="toc-number">50.6.</span> <span class="toc-text">合成聚合复用原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迪米特法则"><span class="toc-number">50.7.</span> <span class="toc-text">迪米特法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-number">51.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是UML"><span class="toc-number">52.</span> <span class="toc-text">什么是UML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML中有哪些常用的图？"><span class="toc-number">53.</span> <span class="toc-text">UML中有哪些常用的图？</span></a></li></ol></div></div><div class="post-content"><h2 id="面向的对象特征"><a href="#面向的对象特征" class="headerlink" title="面向的对象特征"></a>面向的对象特征</h2><ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 </li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。</li>
<li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。</li>
<li>多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。</li>
<li>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）</li>
<li>运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
</li>
</ul>
<h2 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h2><p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/75065795.jpg" alt=""></p>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<h2 id="String-是最基本的数据类型吗？"><a href="#String-是最基本的数据类型吗？" class="headerlink" title="String 是最基本的数据类型吗？"></a>String 是最基本的数据类型吗？</h2><p>不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h2 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h2><p>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h2><p>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<h2 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h2><p>Java 为每个原始类型提供了包装类型：</p>
<ul>
<li>原始类型: boolean，char，byte，short，int，long，float，double </li>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;                  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(a == b);     <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(a == c);     <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(f1 == f2);<span class="comment">//true</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(f3 == f4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>IntegerCache是Integer的内部类，其代码如下所示：</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">     * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">     * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">     * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = <span class="number">-128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) <span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            assert IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false</li>
</ul>
<h2 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h2><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。</p>
<h2 id="解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h2><ul>
<li>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间。</li>
<li>而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；</li>
<li>方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；</li>
<li>程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = new StringBuilder(<span class="string">"go"</span>).append(<span class="string">"od"</span>).toString()<span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.intern() == <span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">String <span class="built_in">s2</span> = new StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString()<span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">s2</span>.intern() == <span class="built_in">s2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h2><p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p>
<h2 id="switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h2><ul>
<li>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。</li>
<li>从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，</li>
<li>从Java 7开始，expr还可以是字符串（String）。</li>
</ul>
<h2 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h2><ul>
<li>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</li>
</ul>
<h2 id="数组有没有length-方法？String有没有length-方法？"><a href="#数组有没有length-方法？String有没有length-方法？" class="headerlink" title="数组有没有length()方法？String有没有length()方法？"></a>数组有没有length()方法？String有没有length()方法？</h2><p>数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</p>
<h2 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h2><p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：</p>
<ul>
<li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ul>
<h3 id="equals方法介绍："><a href="#equals方法介绍：" class="headerlink" title="equals方法介绍："></a>equals方法介绍：</h3><ul>
<li>自反性（x.equals(x)必须返回true）</li>
<li>对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）</li>
<li>传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）</li>
<li>一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），</li>
<li>而且对于任何非null值的引用x，x.equals(null)必须返回false。</li>
</ul>
<h3 id="实现高质量的equals方法的诀窍包括："><a href="#实现高质量的equals方法的诀窍包括：" class="headerlink" title="实现高质量的equals方法的诀窍包括："></a>实现高质量的equals方法的诀窍包括：</h3><ol>
<li>使用==操作符检查”参数是否为这个对象的引用”；</li>
<li>使用instanceof操作符检查”参数是否为正确的类型”；</li>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</li>
<li>重写equals时总是要重写hashCode；</li>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</li>
</ol>
<h2 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h2><p>是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<h2 id="String和StringBuilder、StringBuffer的区别？"><a href="#String和StringBuilder、StringBuffer的区别？" class="headerlink" title="String和StringBuilder、StringBuffer的区别？"></a>String和StringBuilder、StringBuffer的区别？</h2><p>Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<ul>
<li>String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li>
<li>字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class StringEqualTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">               String <span class="built_in">s1</span> = <span class="string">"Programming"</span><span class="comment">;</span></span><br><span class="line">        String <span class="built_in">s2</span> = new String(<span class="string">"Programming"</span>)<span class="comment">;</span></span><br><span class="line">        String <span class="built_in">s3</span> = <span class="string">"Program"</span><span class="comment">;</span></span><br><span class="line">        String <span class="built_in">s4</span> = <span class="string">"ming"</span><span class="comment">;</span></span><br><span class="line">        String <span class="built_in">s5</span> = <span class="string">"Program"</span> + <span class="string">"ming"</span><span class="comment">;</span></span><br><span class="line">        String <span class="built_in">s6</span> = <span class="built_in">s3</span> + <span class="built_in">s4</span><span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="built_in">s1</span> == <span class="built_in">s2</span>)<span class="comment">;//false</span></span><br><span class="line">        System.out.println(<span class="built_in">s1</span> == <span class="built_in">s5</span>)<span class="comment">;//true</span></span><br><span class="line">        System.out.println(<span class="built_in">s1</span> == <span class="built_in">s6</span>)<span class="comment">;//false</span></span><br><span class="line">        System.out.println(<span class="built_in">s1</span> == <span class="built_in">s6</span>.intern())<span class="comment">;//true</span></span><br><span class="line">        System.out.println(<span class="built_in">s2</span> == <span class="built_in">s2</span>.intern())<span class="comment">;//false,返回的常量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><ul>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</li>
</ul>
<h2 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h2><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 </p>
<p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。</p>
<ul>
<li>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。</li>
<li>加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</li>
<li><p>最后JVM对类进行初始化</p>
<ul>
<li>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类</li>
<li>如果类中存在初始化语句，就依次执行这些初始化语句。 </li>
</ul>
</li>
<li><p>类加载器包括：</p>
<ul>
<li>根加载器（BootStrap），一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>扩展加载器（Extension），从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap</li>
<li>系统加载器（System），应用类加载器，其父类是Extension。它是应用最广泛的类加载器</li>
<li>用户自定义类加载器（java.lang.ClassLoader的子类） </li>
</ul>
</li>
<li><p>父亲委托机制<br>从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。</p>
</li>
</ul>
<h2 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h2><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<h2 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ava中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做   new Outer().new Inner();</p>
<h2 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h2><p>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。</p>
<h2 id="GC是什么？为什么要有GC？"><a href="#GC是什么？为什么要有GC？" class="headerlink" title="GC是什么？为什么要有GC？"></a>GC是什么？为什么要有GC？</h2><ul>
<li>Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。</li>
<li>在垃圾收集过程中，可能会将对象移动到不同区域： <ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 </li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</li>
</ul>
</li>
</ul>
<h3 id="与垃圾回收相关的JVM参数："><a href="#与垃圾回收相关的JVM参数：" class="headerlink" title="与垃圾回收相关的JVM参数："></a>与垃圾回收相关的JVM参数：</h3><ol>
<li>-Xms / -Xmx — 堆的初始大小 / 堆的最大大小</li>
<li>-Xmn — 堆中年轻代的大小</li>
<li>-XX:-DisableExplicitGC — 让System.gc()不产生任何作用</li>
<li>-XX:+PrintGCDetails — 打印GC的细节</li>
<li>-XX:+PrintGCDateStamps — 打印GC操作的时间戳</li>
<li>-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小</li>
<li>-XX:NewRatio — 可以设置老生代和新生代的比例</li>
<li>-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布</li>
<li>-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值</li>
<li>-XX:TargetSurvivorRatio：设置幸存区的目标使用率</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        A ab = <span class="keyword">new</span> B();</span><br><span class="line">        ab = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<h2 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别"></a>Error和Exception有什么区别</h2><p>Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h2><ul>
<li>在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。</li>
<li>一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；</li>
<li>throw语句用来明确地抛出一个异常</li>
<li>throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）</li>
</ul>
<h2 id="运行时异常与受检异常有何异同？"><a href="#运行时异常与受检异常有何异同？" class="headerlink" title="运行时异常与受检异常有何异同？"></a>运行时异常与受检异常有何异同？</h2><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： </p>
<p>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） </p>
<ul>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常 </li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） </li>
<li>优先使用标准的异常 </li>
<li>每个方法抛出的异常都要有文档 </li>
<li>保持异常的原子性 </li>
<li>不要在catch中忽略掉捕获到的异常</li>
</ul>
<h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><ul>
<li>ArithmeticException（算术异常） </li>
<li>ClassCastException （类转换异常） </li>
<li>IllegalArgumentException （非法参数异常） </li>
<li>IndexOutOfBoundsException （下标越界异常） </li>
<li>NullPointerException （空指针异常） </li>
<li>SecurityException （安全异常）</li>
</ul>
<h2 id="类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>类ExampleA继承Exception，类ExampleB继承ExampleA。</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">"b"</span>)</span><br><span class="line">&#125; <span class="built_in">catch</span>（ExampleA e）&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"ExampleA"</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span>（Exception e）&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</li>
</ul>
<h2 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h2><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h2 id="阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性。</h2><ul>
<li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>
<li>Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器</li>
<li>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</li>
<li>但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用。</li>
</ul>
<h2 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h2><p>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h2 id="List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点？"></a>List、Map、Set三个接口存取元素时，各有什么特点？</h2><ul>
<li>List以特定索引来存取元素，可以有重复元素。</li>
<li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</li>
<li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li>
<li>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)</li>
</ul>
<h2 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素</h2><ul>
<li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>
<li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li>
<li>Collections工具类的sort方法有两种重载的形式<ul>
<li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li>
<li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则。</li>
</ul>
</li>
</ul>
<h2 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h2><ul>
<li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。</li>
<li>wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<h2 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h2><ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会</li>
<li>yield()方法只会给相同优先级或更高优先级的线程以运行的机会； </li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，</li>
<li>而执行yield()方法后转入就绪（ready）状态；</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； </li>
<li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h2 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h2 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h2><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<h2 id="编写多线程程序有几种实现方式？"><a href="#编写多线程程序有几种实现方式？" class="headerlink" title="编写多线程程序有几种实现方式？"></a>编写多线程程序有几种实现方式？</h2><ul>
<li>一种是继承Thread类；</li>
<li>另一种是实现Runnable接口</li>
<li>实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值</li>
</ul>
<h2 id="什么是线程池（thread-pool）"><a href="#什么是线程池（thread-pool）" class="headerlink" title="什么是线程池（thread pool）"></a>什么是线程池（thread pool）</h2><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： </p>
<ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 </li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 </li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h2 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h2><p><a href="https://img-blog.csdn.net/20150408002007838" target="_blank" rel="noopener"></a></p>
<ul>
<li>其中Running表示运行状态，</li>
<li>Runnable表示就绪状态（万事俱备，只欠CPU），</li>
<li>Blocked表示阻塞状态，阻塞状态又有多种情况，<ul>
<li>可能是因为调用wait()方法进入等待池，</li>
<li>也可能是执行同步方法或同步代码块进入等锁池，</li>
<li>或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</li>
</ul>
</li>
</ul>
<h2 id="简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized 和java.util.concurrent.locks.Lock的异同？</h2><p>Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：</p>
<ul>
<li>Lock 能完成synchronized所实现的所有功能；</li>
<li>Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁</li>
<li>synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</li>
</ul>
<h2 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 </p>
<p>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p>
<h2 id="阐述JDBC操作数据库的步骤。"><a href="#阐述JDBC操作数据库的步骤。" class="headerlink" title="阐述JDBC操作数据库的步骤。"></a>阐述JDBC操作数据库的步骤。</h2><ul>
<li>加载驱动</li>
<li>创建连接</li>
<li>创建语句</li>
<li>执行语句</li>
<li>处理结果</li>
<li>关闭资源</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line"><span class="built_in"> Connection </span>con = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">"select * from emp where sal between ? and ?"</span>);</span><br><span class="line">ps.setInt(1, 1000);</span><br><span class="line">ps.setInt(2, 3000);</span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getInt(<span class="string">"empno"</span>) + <span class="string">" - "</span> + rs.getString(<span class="string">"ename"</span>));</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。</li>
</ul>
<h2 id="Statement和PreparedStatement有什么区别？哪个性能更好？"><a href="#Statement和PreparedStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PreparedStatement有什么区别？哪个性能更好？"></a>Statement和PreparedStatement有什么区别？哪个性能更好？</h2><ul>
<li>PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；</li>
<li>PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；</li>
<li>当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</li>
</ul>
<h2 id="使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h2><ul>
<li>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）</li>
<li>要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。</li>
</ul>
<h2 id="在进行数据库编程时，连接池有什么作用？"><a href="#在进行数据库编程时，连接池有什么作用？" class="headerlink" title="在进行数据库编程时，连接池有什么作用？"></a>在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销。</p>
<h2 id="事务的ACID是指什么？"><a href="#事务的ACID是指什么？" class="headerlink" title="事务的ACID是指什么？"></a>事务的ACID是指什么？</h2><ul>
<li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，</li>
<li>一致性(Consistent)：事务结束后系统状态是一致的；</li>
<li>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； </li>
<li>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</li>
</ul>
<p>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。</p>
<ul>
<li>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</li>
</ul>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/87650429.jpg" alt=""></p>
<ul>
<li>不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</li>
</ul>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/95804465.jpg" alt=""></p>
<ul>
<li>幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行</li>
</ul>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/62660957.jpg" alt=""></p>
<ul>
<li>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</li>
</ul>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/96595208.jpg" alt=""></p>
<ul>
<li>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</li>
</ul>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/65275664.jpg" alt=""></p>
<p>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁：</p>
<p><img src="http://orkt468tj.bkt.clouddn.com/18-7-6/82828779.jpg" alt=""></p>
<h2 id="JDBC中如何进行事务处理？"><a href="#JDBC中如何进行事务处理？" class="headerlink" title="JDBC中如何进行事务处理？"></a>JDBC中如何进行事务处理？</h2><ul>
<li>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；</li>
<li>如果在事务处理过程中发生异常则通过rollback()进行事务回滚。</li>
<li>除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 </li>
</ul>
<h2 id="JDBC能否处理Blob和Clob？"><a href="#JDBC能否处理Blob和Clob？" class="headerlink" title="JDBC能否处理Blob和Clob？"></a>JDBC能否处理Blob和Clob？</h2><p>Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。</p>
<h2 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h2><p>Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作。</p>
<h2 id="简述一下面向对象的”六原则一法则”。"><a href="#简述一下面向对象的”六原则一法则”。" class="headerlink" title="简述一下面向对象的”六原则一法则”。"></a>简述一下面向对象的”六原则一法则”。</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>软件实体应当对扩展开放，对修改关闭。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） </p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>任何时候都可以用子类型替换掉父类型。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口要小而专，绝不能大而全</p>
<h3 id="合成聚合复用原则"><a href="#合成聚合复用原则" class="headerlink" title="合成聚合复用原则"></a>合成聚合复用原则</h3><p>优先使用聚合或合成关系复用代码</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 </p>
<ul>
<li>工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 </li>
<li>代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 </li>
<li>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 </li>
<li>模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 </li>
</ul>
<h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h2><p>UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p>
<h2 id="UML中有哪些常用的图？"><a href="#UML中有哪些常用的图？" class="headerlink" title="UML中有哪些常用的图？"></a>UML中有哪些常用的图？</h2><p>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://chilam.me/2018/06/14/interview-1/" data-id="cjja5fz0a0035g8da161v3dz0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABw0lEQVR42u3aQW7DMAwEwPz/0+61RVF6KdpyGoxOhuFIoxwIkdTrFY/j1/j+Pnmu31w8cHFxx9yjHMk39cLdLZ3MjIuLu5GbL1MvUM+Tz//ne1xc3Dfm1ttIfoWLi/up3LVUBxcX979wk+Qnf86rGTfmari4uANuXqW87/mW+i4uLu4S92iOuhFSl07WVvwxAy4u7hZuHlCSo0/9ZV5IrTeMi4u7n5ukH/X33TJK/tfg4uI+xZ20VJNiSrfREsVdXFzcS7n5kSVPafLgmCdXuLi4z3InjZC1w00jOOLi4m7hdpso3XZp93BzWbsFFxd3zO0uuZbG5GWUk7YNLi7uFu7axYt5M3XSsMHFxX2KW086b6xOrnrg4uLezc0PIknBYp78nPxluLi4G7ndoJPHxe5BZ/EeGS4u7g3cq85Hk8scUfKDi4u7nZsvnGwjeZMnXbi4uHu4R3N0r2hc+z0uLu4ebvcSxqT5mofFJMji4uLezW2nH83jS77VaDO4uLgbud2LF92iSffoM+r94uLibueubW8t9cLFxf0k7ijTqmfGxcXdyO22V7vFkQdyNVxc3AG3HUqaJY9J22ZU38XFxV3hfgHaYeIxKcoASAAAAABJRU5ErkJggg==">Aktie</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a class="pre" href="/2018/06/16/life-dinner-noodle/">黑胡椒意面</a><a class="next" href="/2018/01/04/docker/">1.学习笔记-docker基本概念</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'CasperMXP',
  repo: 'CasperMXP.github.io',
  oauth: {
    client_id: '2cf162fa015e397bb3c9',
    client_secret: '9c97449f4ec96ac4a1064e819e92fde840e66ec7',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/1房2人3餐4季/">1房2人3餐4季</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/搬砖/">搬砖</a><span class="category-list-count">88</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/links/" style="font-size: 15px;">links</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/design-pattern/" style="font-size: 15px;">design-pattern</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/hibernate/" style="font-size: 15px;">hibernate</a> <a href="/tags/hystrix/" style="font-size: 15px;">hystrix</a> <a href="/tags/Hystrix/" style="font-size: 15px;">Hystrix</a> <a href="/tags/ibatis/" style="font-size: 15px;">ibatis</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/test/" style="font-size: 15px;">test</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/jmm/" style="font-size: 15px;">jmm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/logback/" style="font-size: 15px;">logback</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/maths/" style="font-size: 15px;">maths</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring-boot</a> <a href="/tags/security/" style="font-size: 15px;">security</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a> <a href="/tags/javaee/" style="font-size: 15px;">javaee</a> <a href="/tags/weblogic/" style="font-size: 15px;">weblogic</a> <a href="/tags/win10/" style="font-size: 15px;">win10</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/poem-3/">傲红尘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/interview-2/">2.面试准备-框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/links/">1.收藏的一些链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/life-dinner-noodle/">黑胡椒意面</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/interview-1/">1.面试准备-Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/docker/">1.学习笔记-docker基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/spring-boot-8/">8.sb-原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/spring-boot-7/">7.sb-jdbcTemplate</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/spring-boot-6/">6.sb-DevTools</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/spring-boot-5/">5.sb-Swagger</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CHILAM.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zIndex="-1" count="30" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>