<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="java"><title>2.面试准备-框架 | CHILAM</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">2.面试准备-框架</h1><a id="logo" href="/.">CHILAM</a><p class="description">Just Do IT</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">2.面试准备-框架</h1><div class="post-meta">Jun 20, 2018<span> | </span><span class="category"><a href="/categories/搬砖/">搬砖</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5,420</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 19</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#阐述Session加载实体对象的过程。"><span class="toc-number">1.</span> <span class="toc-text">阐述Session加载实体对象的过程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><span class="toc-number">2.</span> <span class="toc-text">锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><span class="toc-number">3.</span> <span class="toc-text">如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟加载与session关闭的矛盾一般可以这样处理："><span class="toc-number">3.1.</span> <span class="toc-text">延迟加载与session关闭的矛盾一般可以这样处理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈一下你对继承映射的理解"><span class="toc-number">4.</span> <span class="toc-text">谈一下你对继承映射的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的hibernate的优化策略"><span class="toc-number">5.</span> <span class="toc-text">常见的hibernate的优化策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OneToMany注解的mappedBy属性有什么作用？"><span class="toc-number">6.</span> <span class="toc-text">@OneToMany注解的mappedBy属性有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis中使用-和-书写占位符有什么区别？"><span class="toc-number">7.</span> <span class="toc-text">MyBatis中使用#和$书写占位符有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释一下MyBatis中命名空间（namespace）的作用。"><span class="toc-number">8.</span> <span class="toc-text">解释一下MyBatis中命名空间（namespace）的作用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是IoC和DI？DI是如何实现的？"><span class="toc-number">9.</span> <span class="toc-text">什么是IoC和DI？DI是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring中Bean的作用域有哪些？"><span class="toc-number">10.</span> <span class="toc-text">Spring中Bean的作用域有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">11.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释一下什么叫AOP（面向切面编程）？"><span class="toc-number">12.</span> <span class="toc-text">解释一下什么叫AOP（面向切面编程）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><span class="toc-number">13.</span> <span class="toc-text">你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring中自动装配的方式有哪些？"><span class="toc-number">14.</span> <span class="toc-text">Spring中自动装配的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？"><span class="toc-number">15.</span> <span class="toc-text">Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC的工作原理是怎样的？"><span class="toc-number">16.</span> <span class="toc-text">Spring MVC的工作原理是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阐述Spring框架中Bean的生命周期？"><span class="toc-number">17.</span> <span class="toc-text">阐述Spring框架中Bean的生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"><span class="toc-number">18.</span> <span class="toc-text">什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring中的BeanFactory和ApplicationContext有什么联系？"><span class="toc-number">19.</span> <span class="toc-text">Spring中的BeanFactory和ApplicationContext有什么联系？</span></a></li></ol></div></div><div class="post-content"><h2 id="阐述Session加载实体对象的过程。"><a href="#阐述Session加载实体对象的过程。" class="headerlink" title="阐述Session加载实体对象的过程。"></a>阐述Session加载实体对象的过程。</h2><ul>
<li>Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回； </li>
<li>如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； </li>
<li>如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回； </li>
<li>如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； </li>
<li>根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象； </li>
<li>将对象纳入Session（一级缓存）的管理； </li>
<li>如果有对应的拦截器，则执行拦截器的onLoad方法； </li>
<li>如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存； </li>
<li>返回数据对象。</li>
</ul>
<h2 id="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><a href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。" class="headerlink" title="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"></a>锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</h2><p>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。 Hibernate支持悲观锁和乐观锁两种锁机制</p>
<ul>
<li>悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，</li>
<li>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</li>
</ul>
<h2 id="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><a href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"></a>如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</h2><p>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</p>
<h3 id="延迟加载与session关闭的矛盾一般可以这样处理："><a href="#延迟加载与session关闭的矛盾一般可以这样处理：" class="headerlink" title="延迟加载与session关闭的矛盾一般可以这样处理："></a>延迟加载与session关闭的矛盾一般可以这样处理：</h3><ul>
<li>关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 </li>
<li>在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 </li>
<li>使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。</li>
</ul>
<h2 id="谈一下你对继承映射的理解"><a href="#谈一下你对继承映射的理解" class="headerlink" title="谈一下你对继承映射的理解"></a>谈一下你对继承映射的理解</h2><p>继承关系的映射策略有三种： </p>
<ul>
<li>每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。 </li>
<li>每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。 </li>
<li>每个具体类一张表（table per concrete class），有多少个子类就有多少张表。 </li>
</ul>
<p>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。<br>后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</p>
<h2 id="常见的hibernate的优化策略"><a href="#常见的hibernate的优化策略" class="headerlink" title="常见的hibernate的优化策略"></a>常见的hibernate的优化策略</h2><ul>
<li>制定合理的缓存策略（二级缓存、查询缓存）。 </li>
<li>采用合理的Session管理机制。 </li>
<li>尽量使用延迟加载特性。 </li>
<li>设定合理的批处理参数。 </li>
<li>如果可以，选用UUID作为主键生成器。 </li>
<li>如果可以，选用基于版本号的乐观锁替代悲观锁。 </li>
<li>在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。 </li>
<li>考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。</li>
</ul>
<h2 id="OneToMany注解的mappedBy属性有什么作用？"><a href="#OneToMany注解的mappedBy属性有什么作用？" class="headerlink" title="@OneToMany注解的mappedBy属性有什么作用？"></a>@OneToMany注解的mappedBy属性有什么作用？</h2><p>@OneToMany用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用<set>标签的inverse=”true”设置来达到同样的效果。</set></p>
<h2 id="MyBatis中使用-和-书写占位符有什么区别？"><a href="#MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="MyBatis中使用#和$书写占位符有什么区别？"></a>MyBatis中使用#和$书写占位符有什么区别？</h2><ul>
<li>井号将传入的数据都当成一个字符串，会对传入的数据自动加上引号；</li>
<li>美元符号将传入的数据直接显示生成在SQL中。</li>
<li>使用美元符号占位符可能会导致SQL注射攻击，</li>
<li>能用井号的地方就不要使用美元符号，写order by子句的时候应该用美元符号而不是井号。</li>
</ul>
<h2 id="解释一下MyBatis中命名空间（namespace）的作用。"><a href="#解释一下MyBatis中命名空间（namespace）的作用。" class="headerlink" title="解释一下MyBatis中命名空间（namespace）的作用。"></a>解释一下MyBatis中命名空间（namespace）的作用。</h2><p>在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<h2 id="什么是IoC和DI？DI是如何实现的？"><a href="#什么是IoC和DI？DI是如何实现的？" class="headerlink" title="什么是IoC和DI？DI是如何实现的？"></a>什么是IoC和DI？DI是如何实现的？</h2><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释，控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。</p>
<p>IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。</p>
<p>DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h2 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h2><p>在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。</p>
<p>Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。</p>
<p>ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法： </p>
<ul>
<li>void set(T value)：设置当前线程的线程局部变量的值。 </li>
<li>T get()：获得当前线程所对应的线程局部变量的值。 </li>
<li>void remove()：删除当前线程中线程局部变量的值。</li>
</ul>
<h2 id="解释一下什么叫AOP（面向切面编程）？"><a href="#解释一下什么叫AOP（面向切面编程）？" class="headerlink" title="解释一下什么叫AOP（面向切面编程）？"></a>解释一下什么叫AOP（面向切面编程）？</h2><p>AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。</p>
<h2 id="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h2><ul>
<li>连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</li>
<li>切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。 </li>
<li>增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。</li>
<li>引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 </li>
<li>织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。 </li>
<li>切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</li>
</ul>
<h2 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h2><ul>
<li>no：不进行自动装配，手动设置Bean的依赖关系。 </li>
<li>byName：根据Bean的名字进行自动装配。 </li>
<li>byType：根据Bean的类型进行自动装配。 </li>
<li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 </li>
<li>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</li>
</ul>
<h2 id="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？"><a href="#Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？" class="headerlink" title="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？"></a>Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？</h2><p>Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p>
<p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p>
<ul>
<li>DataSourceTransactionManager</li>
<li>HibernateTransactionManager</li>
<li>JdoTransactionManager</li>
<li>JtaTransactionManager</li>
<li>PersistenceBrokerTransactionManager</li>
</ul>
<p>Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。</p>
<p>使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。</p>
<h2 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h2><ul>
<li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 </li>
<li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 </li>
<li>在这个地方Spring会通过HandlerAdapter对该处理器进行封装。 </li>
<li>HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 </li>
<li>Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 </li>
<li>ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 </li>
<li>当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 </li>
<li>客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</li>
</ul>
<h2 id="阐述Spring框架中Bean的生命周期？"><a href="#阐述Spring框架中Bean的生命周期？" class="headerlink" title="阐述Spring框架中Bean的生命周期？"></a>阐述Spring框架中Bean的生命周期？</h2><p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">很详细的参考链接</a></p>
<p><img src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt=""></p>
<p><img src="http://images.51cto.com/files/uploadimg/20110419/0930070.png" alt=""></p>
<ul>
<li>Spring IoC容器找到关于Bean的定义并实例化该Bean。 </li>
<li>Spring IoC容器对Bean进行依赖注入。 </li>
<li>如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。 </li>
<li>如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。 </li>
<li>如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法</li>
<li>如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。 </li>
<li>如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。 </li>
<li>当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。</li>
</ul>
<p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<ol>
<li>Bean自身的方法这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></li>
<li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li>
<li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li>
<li>工厂后处理器接口方法这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>
</ol>
<h2 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</h2><ul>
<li>XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 </li>
<li>SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；</li>
<li>CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；</li>
</ul>
<h2 id="Spring中的BeanFactory和ApplicationContext有什么联系？"><a href="#Spring中的BeanFactory和ApplicationContext有什么联系？" class="headerlink" title="Spring中的BeanFactory和ApplicationContext有什么联系？"></a>Spring中的BeanFactory和ApplicationContext有什么联系？</h2><ul>
<li>Spring通过配置文件描述Bean以及Bean之间的依赖关系，利用Java的反射机制实现Bean的实例化，并建立Bean之间的依赖关系，在此基础上，Spring的IoC容器还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。BeanFactory是Spring框架最核心的接口，它提供了IoC容器的配置机制。</li>
<li>ApplicationContext建立在BeanFactory之上，提供了更多面向应用的功能，包括对国际化和框架事件体系的支持。通常将BeanFactory称为IoC容器，而ApplicationContext称为应用上下文，前者更倾向于Spring本身，后者更倾向于开发者，因此被使用得更多。</li>
<li></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://chilam.me/2018/06/20/interview-2/" data-id="cjkt0trza003efr8knoiu3icw" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3aSZLDIAwF0Nz/0u4DdBm+kCFDPVapTDy8UGng9YrXdbP+f+fu9fidhxcuLm6bew1Xf4PxMXIDLi7ueW51m3Eg6/z/5Le4uLgfzL37bY7AxcX9PW6n1MHFxf0WblL8lAuVuLGypVbDxcVtcJ9tbXTSo4f7u7i4uEvcq7iqBUw1YE12x8XFPcLNA0qecFSTnvK+uLi4m7mddsZamyP/dPJccXFxN3MTUKeBstYknWRkuLi427jVxseOZuhiWMTFxT3CrSYxnfQlL5Ym++Li4m7grg1Hk0HLU6XRpPjBxcXdwO2kKcmB87CVl0y4uLi7udU2x5j41PFuDbi4uG/ldpKYavpSaJHg4uIe4eZJydogdq34KVzRwMXF3cZNUpa1EUue+pTvkeHi4h7hRl8tBr68OVIowHBxcQ9y8xJoLfBVL3Ms3vXAxcVtc6/iWgtDnfEtLi7ueW6+krFoPjrNS6nFw+Di4ra51fKj2uaoXumYHAYXF/cgN2l05oPSTgQtT3twcXE/hptf1+iUXri4uN/LHacp/ZbHAykOLi7uErd6dTIvZt5Wq+Hi4ja45VASv782gBk/FFxc3M3cP26DAS/9ccG4AAAAAElFTkSuQmCC">Aktie</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a class="pre" href="/2018/08/11/nodejs/">nodejs</a><a class="next" href="/2018/06/17/links/">1.收藏的一些链接</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'CasperMXP',
  repo: 'CasperMXP.github.io',
  oauth: {
    client_id: '2cf162fa015e397bb3c9',
    client_secret: '9c97449f4ec96ac4a1064e819e92fde840e66ec7',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/1房2人3餐4季/">1房2人3餐4季</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/搬砖/">搬砖</a><span class="category-list-count">94</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/links/" style="font-size: 15px;">links</a> <a href="/tags/bable/" style="font-size: 15px;">bable</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/design-pattern/" style="font-size: 15px;">design-pattern</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/hibernate/" style="font-size: 15px;">hibernate</a> <a href="/tags/hystrix/" style="font-size: 15px;">hystrix</a> <a href="/tags/Hystrix/" style="font-size: 15px;">Hystrix</a> <a href="/tags/ibatis/" style="font-size: 15px;">ibatis</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/test/" style="font-size: 15px;">test</a> <a href="/tags/modules/" style="font-size: 15px;">modules</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/jmm/" style="font-size: 15px;">jmm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/logback/" style="font-size: 15px;">logback</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/maths/" style="font-size: 15px;">maths</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring-boot</a> <a href="/tags/security/" style="font-size: 15px;">security</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a> <a href="/tags/javaee/" style="font-size: 15px;">javaee</a> <a href="/tags/weblogic/" style="font-size: 15px;">weblogic</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/win10/" style="font-size: 15px;">win10</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/webpack/">webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/javascript-modules/">前端模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/11/react/">react</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/11/babel/">babel</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/11/nodejs/">nodejs</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/interview-2/">2.面试准备-框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/links/">1.收藏的一些链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/life-dinner-noodle/">黑胡椒意面</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/interview-1/">1.面试准备-Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/docker/">1.学习笔记-docker基本概念</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CHILAM.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zIndex="-1" count="30" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>